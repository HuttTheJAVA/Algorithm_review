각 값 별 유니온이 할당됨.
유니온은 자기보다는 작지만 그 중 가장 큰수가 저장된다. 즉, 정렬된 배열 기준 자기 왼쪽 값이 자기 유니온이다.

다음, 각 k개의 자연수가 주어지면 이 Ki번째 자연수에 대해 이분 탐색을 한다. 그전에 이 Ki가 범위내의 값인지 확인한다.
								|___> 범위를 벗어나면(크든 작든), 가장 작은 값을 가지는 카드를 낸다.
중앙값을 보았을 때 중앙값이 Ki번째 수 보다 작으면 더 이상 진행하지 않고 start를 중앙값으로 바꿔 다시 이분탐색
중앙값이 Ki보다 크면, 다음 2가지 조건을 따지는데 1. 현재 중앙값이 유효한가?  이 값을 일단 저장한다.
							|____> 유효하지 않으면, 아래 2번 조건을 따진다. 2번 조건 따졌을 때 왼쪽에 마땅한 값이 없으면, start를 중앙 값으로 설정하고 다시 이분탐색.
					  2. 현재 중앙값의 left_num = find(중앙값 union)을 했을 때, 이 값이 유효하고 Ki보다 큰가? => 현재 중앙값을 end로 하고 이분탐색 다시 시작
													|___> 작으면 현재 이 중앙값이 Ki보다 큰 값들 중 가장 작은 값이므로 이값을 채택.
					어떤 값이 결국에 선택되면, 이 값의 유니온을 이값이 저장하고 있는 유니온값의 유니온으로 바꾼다.(부모의 부모로 = 유효한 값이 나올때 까지 if parten[x] == avail[x])
					값을 할당하지 못했으면, Ki보다 큰 수가 없으면 가장 작은 값을 가지는 카드를 낸다.
										    |___> 중앙값을 보았을 때 중앙값의 유니온이 유효한 값이면 무조건 왼쪽 탐색
											유효한 값이 없으면, 중앙값이 유효한 값이면 중앙값을 채택,
											중앙값도 유효하지 않으면, 오른쪽 탐색.
