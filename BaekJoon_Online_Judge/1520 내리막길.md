![image](https://user-images.githubusercontent.com/92637789/221116776-1cee49fd-a675-49a2-b78c-fbf5e3855af3.png)

---------

이 문제는 왼쪽 맨위칸에서 오른쪽 맨 아래칸으로 이동하고 싶은데 이동 가능한 경로의 개수를 구하고  싶은 문제다 이동은 현재칸에서 다음칸으로 갈 곳의 숫자가 더 작으면 다음 칸으로
이동할 수 있다.    
먼저 문제를 보고 dfs가 생각났고 단순 dfs를 돌려 목적지 칸에 도착할 때 마다(어느 경로든지) count 1씩 올리는 방법으로 코드를 짯다. 당연히 시간 초과가 났다.   
근데 dp를 이용하지 않는 이상 시간 초과난 코드의 시간 복잡도를 줄일 수 있는 방법이 도무지 생각나지 않았다.   
혹시나 하고 알고리즘 분류를 까봤다. 역시나 다이나믹 프로그래밍이 있었다.   
그래서 dp관점으로 줄일 수 있는 방안을 생각하다가. dfs나 bfs가 유한한 시간안에 끝나는 이유는 방문처리를 하기 때문이다.   
그래서 이 논리에 입각해 이미 방문한 칸은 다시 재귀적으로 dfs 탐색을 하지 않도록 그 칸으로 갔을 때 맨 오른쪽 맨 아래칸에 도달할 수 있는 경로의 개수를 저장해 놓자고 생각했다.   
예를 들어 다음칸으로 갔을 때 목적지에 도착할 수 있는 경로의 개수가 5라면(그 전 사람(?)이 그 칸을 이미 다 방문해 봤고 그 결과 5개의 경로가 있는 것이다.)   
굳이 그 칸을 다시 가지않고 그냥 경로의 개수 변수에 5를 더하고 재귀를 수행하지 않는다.   
이렇게 되면 서로 다른 경로에서 중복되는 방문 칸들을 중복 방문하지 않게되고, 결과적으로 많아봐야 N x M칸을 방문하므로 시간 복잡도는 (N x M)가 된다.

dp 너무 어렵다 한 문제 한 문제가 진짜 묵직허다.
