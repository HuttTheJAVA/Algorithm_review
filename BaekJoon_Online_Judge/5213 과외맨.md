
<p align = "center"><img src = "https://user-images.githubusercontent.com/92637789/224247645-0c1f8875-3565-4211-ad3c-2b79b9d84ca7.png" height="1100x" width="1000x" ></p>

-------
## 로직
먼저 같은 타일을 공유하는 칸 끼리는 같은 시작 점으로 부터의 거리를 가진다.그리고 bfs에서 다음 칸으로 이동하는 조건은 현재 칸의 번호와   
인접한 칸의 번호가 같고, 인접한 칸의 최소 도달 거리가 현재 칸의 최소 도달 거리 + 1 보다 크면 인접칸으로 이동한다(즉, bfs 큐에 다음 칸을 삽입한다.)   
근데 이 문제의 난관은 인접 칸 이동하는데에 있다. 행렬의 모든 행이 똑같은 열을 가지는게 아니라서 예외 처리할 부분이 많았다. 인접칸의 이동은 아래 사진과 같이 처리했다.  <br></br>  
여기서 nx는 다음 칸의 행,  <br></br> 
ny는 다음 칸의 열   <br></br> 
L_or_R은 현재 위치가 x,y의(타일) 왼쪽인지, 오른쪽인지 구별하기 위한것. 0 = 왼, 1 = 오른쪽.   <br></br> 
Next_L_or_R는 이동할 다음 칸이 다음 칸 타일의 왼쪽인지, 오른쪽인지 구별하기 위한 변수.<br></br>

-------
![image](https://user-images.githubusercontent.com/92637789/224249514-ae3dcb05-2398-4997-afd1-257954da0901.png)   

-------

추가적으로 각 칸의 거리를 저장하는 행렬과 각 타일로 도달하기 전의 타일 번호를 저장하는 리스트도 선언했다.   
(즉 index = 현재 타일 번호,value = 현재 타일로 도달하기 전의 타일 번호)   
처음 1번 타일에서 시작해서 bfs를 돌리며 매 칸의 도달 거리를 최신화하고(두 타일 중 하나의 칸이 최신화 됐으면 나머지 다른 칸도 무조건 최신화 한다.),   
최신화 된 칸의 이전 칸을 저장하는 리스트도 최신화한다.(이동 순서를 출력해야 하기 때문)

그리고 최종적으로 bfs가 끝나면, 맨 마지막 타일로 도달하기 위한 최소 거리가 sys.maxsize(초기 값)가 아니라면 (그 칸에 해당하는 값이 초기 값이라면 그 칸으로 도달하지 못한 것이다.)   
최종 칸의 최소 도달 거리를 출력하고, 이동 순서를 lst에 담아가며 lst의 반대로 출력한다.   
근데 만약에 마지막 타일에 도달하지 못했으면 그 때는 가장 번호가 뒤에인 칸에 도달하기 위한 최소 거리와 이동 순서를 출력해야 한다.   
이거는 그냥 타일 번호를 뒤에서 부터 순회하면서 최소 도달 거리가 sys.maxsize(초기 값)이 아닌 칸을 기준으로 잡으면 된다.   

-----
<p align = "center"><img src = "https://user-images.githubusercontent.com/92637789/224251247-b764742d-2d0a-48f5-8e1a-5ad111dd93c4.png" height="230x" width="700x" ></p>
빡 집중해서 풀면 1시간 후반대 까지 끌어 올릴 수 있을 거 같은데, 구현량 많은 문제는 집중력 유지하기가 어렵다.   
자꾸 시분할로 문제를 풀려고 한다.(코딩 -> 유튜브 -> 코딩 -> 밥.. -> solve)   
그리고 문제를 풀 수 있겠다하는 확신을 가지고 접근하는 것과 얘매한 확신을 가지고 접근할 때 문제를 치고 나가는 속도도 현저히 차이난다. 일단 틀리는 것을 두려워 하지 않고   
맞히는 것도 좋지만 먼저 푸는 과정에 의의를 둬야겠다.
