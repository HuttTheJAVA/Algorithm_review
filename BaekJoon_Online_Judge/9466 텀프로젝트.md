이 문제의 요점은 학생별로 팀원으로 함께 하고 싶은 다른 학생을 선택하는데,
선택 학생 집합과 선택 받은 학생 집합에 속하는 구성원이 일치해야 한다.
아래 그림을 봤을 때, 4,6,7번 팀 과 3번 팀
총 2개의 팀이 만들어 질 수 있다.(팀 구성인원은 제한 x)
결론적으로 문제의 output은 어느 팀에도 속하지 않는 학생 수 를 출력하면 된다.
그림의 경우 1,2,5번 학생들이 어느 팀에도 속하지 못했고 답은 3이 된다.

문제의 접근은 다음과 같다, 일단 팀이 결성되기 위한 조건은 방향 그래프라고 쳤을 때,
사이클이 발생해야 팀이 결성 된 것이다. 사이클의 판단 여부는 유니온 파인드 알고리즘에 맡겼다. 
좌측 그림을 보면, 모든 노드는 한 유니온에 속한다, 
그러나 사이클에 속하는 노드는 3,4,5,6,7,8 6개 뿐이다.
1,2는 어느 팀에도 속하지 못한것이다. 이거를 코드로 어떻게 구현하냐면,
먼저 나의노드와 내가 원하는 노드의 유니온을 보았을 때 다른 유니온이면 
parent[나의 노드] = parent[내가 원하는 노드]로 설정한다.
만약 같은 유니온이면, 나를 기준으로 qu에 담고 while(qu):일 때
노드를 pop하고 그 노드가 가르키는 노드를 또 qu에 담는다.
그러면, 8 -> 3 -> 4 -> 5 -> 6 -> 7 순으로 담길 것이고
1,2는 아무도 지명하지 않았기에 유니온이 같아도 큐에 담기지 않는다.
근데 학생 수가 최대 100,000명 이라서 재귀로 유니온 find를 하게되면,
최대 100,000번의 재귀 껍질이 생긴다. 그래서 recursion error가 생겼었다.
해결 방법은 sys.setrecursionlimit(10**7)로 하니까 해결 됐다.

![image](https://user-images.githubusercontent.com/92637789/209627323-1927f653-1b1a-4e76-ae64-90102d792a72.png)

![image](https://user-images.githubusercontent.com/92637789/209627359-7cc7434d-c687-4701-af1d-9b797c879295.png)
